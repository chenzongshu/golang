# 协程

多线程开发设计要考虑很多同步竞争等问题，如锁、竞争冲突等。

其实一个线程分为 “内核态 “线程和” 用户态 “线程。

**一个 “用户态线程” 必须要绑定一个 “内核态线程”**，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。

然后就设计了这么一套东西：内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”

协程和内核态线程可以1：1，也可以N：1，也可以M：N，其中

协程跟线程是有区别的，线程由 CPU 调度是抢占式的，**协程由用户态调度是协作式的**，一个协程让出 CPU 后，才执行下一个协程

# GMP

## 概念

- G：goroutine协程
- M：thread线程，最大数受内核限制或者SetMaxThreads函数设置
- P：processor处理器，包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列，所以P的最大数代表了任意时刻G的可运行的最大数。

## 模型

在 Go 中，**线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上**。

```
┌──────────────────────────────────────────────────────────┐
│                       全局队列                            │
│                 ┌────────────────────┐                   │
│           in    │ ┌───┐  ┌───┐ ┌───┐ │    out            │
│     ───────────▶│ │ G │  │ G │ │ G │ │────────▶          │
│                 │ └───┘  └───┘ └───┘ │                   │
│                 └────────────────────┘                   │
│                                                          │
│            ┌─────┐      ┌─────┐     ┌─────┐              │
│            │┌───┐│      │     │     │     │ P本地队列     │
│            ││ G ││      │     │     │     │              │
│            │└───┘│      │     │     │     │              │
│Goroutine   │┌───┐│      │┌───┐│     │┌───┐│              │
│Scheduler   ││ G ││      ││ G ││     ││ G ││              │
│            │└───┘│      │└───┘│     │└───┘│              │
│            │┌───┐│      │┌───┐│     │┌───┐│              │
│            ││ G ││      ││ G ││     ││ G ││              │
│            │└───┘│      │└───┘│     │└───┘│              │
│            └──┬──┘      └──┬──┘     └──┬──┘              │
│               ▼            ▼           ▼                 │
│             ┌───┐        ┌───┐       ┌───┐               │
│             │ P │        │ P │       │ P │◀────GOMAXPROCS│
│             └───┘        └───┘       └───┘               │
└───────────────▲────────────▲───────────▲─────────────────┘
            ┌───┘        ┌───┘    ┌──────┘                  
            │            │        │           空闲              
          ┌───┐       ┌───┐     ┌───┐      ┌───┐            
          │M0 │       │M1 │     │M2 │      │M3 │   内核线程         
          └───┘       └───┘     └───┘      └───┘            
            ▲           ▲         ▲          ▲              
  ┌─────────┴───────────┴─────────┴──────────┴──────────┐   
  │                    OS Scheduler                     │   
  └──────────▲──────────────▲───────────────▲───────────┘   
             │              │               │               
          ┌──┴─┐         ┌──┴─┐          ┌──┴─┐             
          │CPU │         │CPU │          │CPU │             
          └────┘         └────┘          └────┘             
```

- **全局队列（Global Queue）**：存放等待运行的 G。
- **P 的本地队列**：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。
- **P 列表**：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
- **M**：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

> M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

**Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行**。

### go func（）调度流程

1、我们通过 go func () 来创建一个 goroutine；

2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；

3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会向其他的 MP 组合偷取一个可执行的 G 来执行；

4、一个 M 调度 G 执行的过程是一个循环机制；

5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；

6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。

### 调度器生命周期



特殊的M0和G0

